# Презентация по лабораторной работе №5
## Вероятностные алгоритмы проверки чисел на простоту

---

## Слайд 1: Титульный слайд

**Лабораторная работа №5**  
Вероятностные алгоритмы проверки чисел на простоту

**Дисциплина:**  
Математические основы защиты информации и информационной безопасности

**Выполнила:**  
Назарова Дарья Владиславовна

---

## Слайд 2: Цель работы

- Ознакомиться с вероятностными алгоритмами проверки чисел на простоту
- Изучить математические основы тестов:
  - Тест Ферма
  - Тест Соловэя-Штрассена  
  - Тест Миллера-Рабина
- Реализовать алгоритмы на языке программирования Julia
- Провести тестирование и сравнение эффективности алгоритмов

---

## Слайд 3: Теоретическая основа

### Понятие простого числа
Числа, имеющие только тривиальные делители (±1, ±p)

### Вероятностные алгоритмы
- Используют генератор случайных чисел
- Дают ответ с определенной вероятностью точности
- Вероятность ошибки: ≤ 1/2^t после t итераций
- Никогда не ошибаются в определении составных чисел
- Широко применяются в криптографии с открытым ключом

---

## Слайд 4: Тест Ферма

### Основа: Малая теорема Ферма
```
a^(p-1) ≡ 1 (mod p) для простого p
```

### Алгоритм:
1. Выбрать случайное a ∈ [2, n-2]
2. Вычислить a^(n-1) mod n
3. Если результат ≠ 1 - число составное
4. Повторить k раз

### Характеристики:
- ✅ Простота реализации
- ❌ Наличие чисел Кармайкла

---

## Слайд 5: Символ Якоби

### Назначение
Обобщение символа Лежандра для составных модулей

### Основные свойства:
- `(0/n) = 0`
- `(1/n) = 1`  
- `(2/n)` зависит от `n mod 8`
- Квадратичный закон взаимности

### Применение
Используется в тесте Соловэя-Штрассена

```julia
jacobi_symbol(2, 7)  # Результат: 1
```

---

## Слайд 6: Тест Соловэя-Штрассена

### Основа: Критерий Эйлера
```
a^((n-1)/2) ≡ (a/n) (mod n)
```

### Алгоритм:
1. Выбрать случайное a ∈ [2, n-2]
2. Вычислить r = a^((n-1)/2) mod n
3. Вычислить символ Якоби s = (a/n)
4. Если r ≠ s mod n - число составное
5. Повторить k раз

### Надежность: Выше чем у теста Ферма

---

## Слайд 7: Тест Миллера-Рабина

### Основа: Разложение
```
n-1 = 2^s · r, где r - нечетное
```

### Алгоритм:
1. Представить n-1 = 2^s · r
2. Выбрать случайное a ∈ [2, n-2]
3. Вычислить последовательность:
   - y₀ = a^r mod n
   - y₁ = y₀² mod n
   - ...
   - y_s = y_{s-1}² mod n
4. Проверить условия простоты

### Преимущества: Наиболее надежный вероятностный тест

---

## Слайд 8: Реализация на Julia

### Особенности реализации:
- Модульное возведение в степень
- Рекурсивное вычисление символа Якоби
- Обработка граничных случаев
- Параметризация количества итераций

### Пример использования:
```julia
# Тест Ферма
fermat_test(101, 10)  # "Число 101, вероятно, простое"

# Тест Соловэя-Штрассена  
solovay_strassen_test(101, 10)  # "Число 101, вероятно, простое"

# Тест Миллера-Рабина
miller_rabin_test(101, 10)  # "Число 101, вероятно, простое"
```

---

## Слайд 9: Результаты тестирования

### Тестовые данные:
Простые: 5, 13, 17, 23, 29, 31  
Составные: 9, 15, 21, 33

### Результаты:
- ✅ Все алгоритмы корректно определили простые числа
- ✅ Все алгоритмы корректно определили составные числа  
- ✅ Тест Миллера-Рабина показал наибольшую надежность

### Вероятность ошибки:
≤ 0.001 при 10 итерациях (1/1024)

### Пример вывода:
```
Тест Ферма для 15: "Число 15 составное"
Тест Миллера-Рабина для 17: "Число 17, вероятно, простое"
```

---

## Слайд 10: Выводы и заключение

### Итоги работы:
- ✅ Успешно реализованы 3 вероятностных теста простоты
- ✅ Проведено сравнительное тестирование алгоритмов  
- ✅ Изучены математические основы проверки чисел на простоту
- ✅ Освоен язык программирования Julia
