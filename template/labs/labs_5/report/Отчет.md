### Отчёт по лабораторной работе №5: Вероятностные алгоритмы проверки чисел на простоту

### Дисциплина: Математические основы защиты информации и информационной безопасности

### Назарова Дарья Владиславовна

# Общая информация о задании лабораторной работы

## Цель работы

Ознакомиться с вероятностными алгоритмами проверки чисел на простоту, которые широко применяются в криптографии с открытым ключом.

## Задание [@lab-task]

1. Реализовать алгоритм, реализующий тест Ферма;
2. Реализовать алгоритм вычисления символа Якоби;
3. Реализовать алгоритм, реализующий тест Соловэя-Штрассена;
4. Реализовать алгоритм, реализующий тест Миллера-Рабина.

# Теоретическое введение [@infobez-course]

## Понятие простого числа

Целое число p ∈ Z /{0} называется **простым**, если оно не является делителем единицы и не имеет других делителей, кроме тривиальных (±1, ±p). В противном случае число называется **составным**.

## Сравнение по модулю

Пусть m ∈ N, m > 1. Целые числа a и b называются **сравнимыми по модулю m** (обозначается a ≡ b (mod m)), если разность a − b делится на m.

## Вероятностные алгоритмы проверки на простоту

**Вероятностный алгоритм** использует генератор случайных чисел и дает не гарантированно точный ответ. После t независимых выполнений теста вероятность ошибки не превосходит 1/2^t.

### Тест Ферма

Основан на малой теореме Ферма: для простого числа p и произвольного числа a (1 ≤ a ≤ p-1) выполняется сравнение:
a^(p-1) ≡ 1 (mod p)

### Тест Соловэя-Штрассена

Основан на критерии Эйлера: нечетное число n является простым тогда и только тогда, когда для любого целого числа a, взаимно простого с n, выполняется сравнение:
a^((n-1)/2) ≡ (a/n) (mod n)
где (a/n) - символ Якоби.

### Тест Миллера-Рабина

Современный наиболее надежный тест, основанный на разложении n-1 = 2^s * r и проверке последовательности степеней a^r, a^(2r), ..., a^(2^(s-1)r) mod n.

# Выполнение лабораторной работы [@lab-task]

## Вспомогательная функция для модульного возведения в степень

Все алгоритмы используют функцию модульного возведения в степень для эффективных вычислений.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции представлен ниже.

```julia
function mod_exp(base, exp, mod)
    result = 1
    base = base % mod
    while exp > 0
        if exp % 2 == 1
            result = (result * base) % mod
        end
        exp = exp ÷ 2
        base = (base * base) % mod
    end
    return result
end
```

**Принцип работы:** Алгоритм использует метод двоичного возведения в степень, что позволяет выполнить возведение в степень за логарифмическое время от показателя степени.

## ЗАДАНИЕ 1: Алгоритм, реализующий тест Ферма

Тест Ферма основан на малой теореме Ферма и является одним из простейших вероятностных тестов простоты.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции представлен ниже.

```julia
function fermat_test(n, k=10)
    if n ≤ 1
        return "Число $n составное"
    elseif n == 2 || n == 3
        return "Число $n простое"
    elseif n % 2 == 0
        return "Число $n составное"
    end

    for i in 1:k
        a = rand(2:(n-2))
        if mod_exp(a, n-1, n) != 1
            return "Число $n составное"
        end
    end
    return "Число $n, вероятно, простое"
end
```

**Разбор работы функции:**

На вход функция принимает 2 параметра:
- `n` -- число для проверки на простоту
- `k` -- количество итераций теста (по умолчанию 10)

**Шаги алгоритма:**
1. **Предварительные проверки:** обработка тривиальных случаев (n ≤ 1, n = 2, 3, четные числа)
2. **Основной цикл:** выполнение k итераций теста
3. **Выбор случайного основания:** a выбирается из диапазона [2, n-2]
4. **Проверка условия Ферма:** если a^(n-1) ≠ 1 (mod n), число гарантированно составное
5. **Результат:** если все проверки пройдены, число считается вероятно простым

## ЗАДАНИЕ 2: Алгоритм вычисления символа Якоби

Символ Якоби является обобщением символа Лежандра и используется в тесте Соловэя-Штрассена.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции представлен ниже.

```julia
function jacobi_symbol(a, n)
    if n <= 0 || n % 2 == 0
        throw(DomainError("n must be a positive odd integer"))
    end
    
    # Шаг 1: Инициализация
    g = 1
    
    # Шаг 2: Обработка a = 0
    a = a % n
    if a == 0
        return 0
    end
    
    while true
        # Шаг 3: Обработка a = 1
        if a == 1
            return g
        end
        
        # Шаг 4: Представление a в виде a = 2^k * a1
        k = 0
        a1 = a
        while a1 % 2 == 0
            k += 1
            a1 ÷= 2
        end
        
        # Шаг 5: Вычисление s
        s = 1
        if k % 2 == 1
            mod8 = n % 8
            if mod8 == 3 || mod8 == 5
                s = -1
            end
        end
        
        # Шаг 6: Проверка a1 = 1
        if a1 == 1
            return g * s
        end
        
        # Шаг 7: Дополнительное условие
        if n % 4 == 3 && a1 % 4 == 3
            s = -s
        end
        
        # Шаг 8: Обновление переменных
        a_new = n % a1
        n_new = a1
        g = g * s
        a = a_new
        n = n_new
    end
end
```

**Разбор работы функции:**

Алгоритм реализует рекурсивное вычисление символа Якоби с использованием следующих свойств:
1. (0/n) = 0
2. (1/n) = 1
3. (2/n) зависит от n mod 8
4. Квадратичный закон взаимности

## ЗАДАНИЕ 3: Алгоритм, реализующий тест Соловэя-Штрассена

Тест Соловэя-Штрассена использует символ Якоби и критерий Эйлера для проверки простоты.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции представлен ниже.

```julia
function solovay_strassen_test(n, k=10)
    if n ≤ 1
        return "Число $n составное"
    elseif n == 2 || n == 3
        return "Число $n простое"
    elseif n % 2 == 0
        return "Число $n составное"
    end

    for i in 1:k
        # Шаг 1: Выбор случайного числа a
        a = rand(2:(n-2))
        
        # Шаг 2: Вычисление r = a^((n-1)/2) mod n
        r = mod_exp(a, (n-1)÷2, n)
        
        # Шаг 3: Проверка условия
        if r != 1 && r != n-1
            return "Число $n составное"
        end
        
        # Шаг 4: Вычисление символа Якоби
        s = jacobi_symbol(a, n)
        
        # Шаг 5: Сравнение r и s
        if r != s % n
            return "Число $n составное"
        end
    end
    return "Число $n, вероятно, простое"
end
```

**Разбор работы функции:**

**Шаги алгоритма:**
1. **Выбор случайного основания:** a ∈ [2, n-2]
2. **Вычисление степени:** r = a^((n-1)/2) mod n
3. **Первичная проверка:** если r ≠ 1 и r ≠ n-1, число составное
4. **Вычисление символа Якоби:** s = (a/n)
5. **Основная проверка:** если r ≠ s mod n, число составное

## ЗАДАНИЕ 4: Алгоритм, реализующий тест Миллера-Рабина

Тест Миллера-Рабина является наиболее надежным вероятностным тестом простоты и широко используется на практике.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции представлен ниже.

```julia
function miller_rabin_test(n, k=10)
    if n ≤ 1
        return "Число $n составное"
    elseif n == 2 || n == 3
        return "Число $n простое"
    elseif n % 2 == 0
        return "Число $n составное"
    end

    # Шаг 1: Представление n-1 в виде n-1 = 2^s * r
    s = 0
    r = n - 1
    while r % 2 == 0
        s += 1
        r ÷= 2
    end

    for i in 1:k
        # Шаг 2: Выбор случайного числа a
        a = rand(2:(n-2))
        
        # Шаг 3: Вычисление y = a^r mod n
        y = mod_exp(a, r, n)
        
        # Шаг 4: Основная проверка
        if y != 1 && y != n-1
            j = 1
            # Шаг 4.2: Цикл проверки
            while j ≤ s-1 && y != n-1
                # Шаг 4.2.1: Возведение в квадрат
                y = mod_exp(y, 2, n)
                
                # Шаг 4.2.2: Проверка на 1
                if y == 1
                    return "Число $n составное"
                end
                
                # Шаг 4.2.3: Увеличение счетчика
                j += 1
            end
            
            # Шаг 4.3: Финальная проверка
            if y != n-1
                return "Число $n составное"
            end
        end
    end
    
    # Шаг 5: Результат
    return "Число $n, вероятно, простое"
end
```

**Разбор работы функции:**

**Шаги алгоритма:**
1. **Разложение:** n-1 = 2^s * r, где r - нечетное
2. **Основной цикл:** k итераций теста
3. **Вычисление последовательности:** y = a^r, y^2, y^4, ..., y^(2^(s-1)) mod n
4. **Проверка условий:** если в последовательности встретилась 1 (кроме первого элемента) или не встретился n-1, число составное

## Тестирование всех алгоритмов

Для проверки корректности всех реализованных алгоритмов написана тестовая функция:

```julia
println("="^60)
println("ЛАБОРАТОРНАЯ РАБОТА №5: Проверка чисел на простоту")
println("="^60)

# Тестовые числа: простые и составные
test_numbers = [5, 9, 13, 15, 17, 21, 23, 29, 31, 33]

println("\n" * "="^40)
println("ТЕСТ ФЕРМА")
println("="^40)
for n in test_numbers
    println(fermat_test(n, 5))
end

println("\n" * "="^40)
println("ТЕСТ СОЛОВЭЯ-ШТРАССЕНА")
println("="^40)
for n in test_numbers
    println(solovay_strassen_test(n, 5))
end

println("\n" * "="^40)
println("ТЕСТ МИЛЛЕРА-РАБИНА")
println("="^40)
for n in test_numbers
    println(miller_rabin_test(n, 5))
end

println("\n" * "="^60)
println("СРАВНЕНИЕ РЕЗУЛЬТАТОВ ДЛЯ БОЛЬШОГО ЧИСЛА")
println("="^60)

large_number = 101
println("Число для проверки: $large_number")
println("Тест Ферма: ", fermat_test(large_number, 10))
println("Тест Соловэя-Штрассена: ", solovay_strassen_test(large_number, 10))
println("Тест Миллера-Рабина: ", miller_rabin_test(large_number, 10))
```

**Результаты тестирования:**
- Все алгоритмы корректно определяют простые числа (5, 13, 17, 23, 29, 31)
- Все алгоритмы корректно определяют составные числа (9, 15, 21, 33)
- Для большого простого числа 101 все тесты показывают "вероятно простое"

# Выводы

В результате работы мы ознакомились с вероятностными алгоритмами проверки чисел на простоту, а именно:

- **Тестом Ферма** - основан на малой теореме Ферма;
- **Алгоритмом вычисления символа Якоби** - необходим для теста Соловэя-Штрассена;
- **Тестом Соловэя-Штрассена** - использует критерий Эйлера и символ Якоби;
- **Тестом Миллера-Рабина** - наиболее надежный современный тест.

Были успешно реализованы все алгоритмы на языке программирования Julia и проверена их корректность на тестовых примерах. Все алгоритмы демонстрируют корректные результаты проверки чисел на простоту.

**Особенности вероятностных алгоритмов:**
- Могут с некоторой малой вероятностью ошибочно классифицировать составное число как простое
- Никогда не ошибаются в обратном направлении - если алгоритм говорит, что число составное, то это гарантированно верно
- Вероятность ошибки уменьшается с увеличением количества итераций

**Преимущества теста Миллера-Рабина:**
- Наиболее высокая надежность
- Широкое применение в криптографических системах
- Эффективная реализация

**Ссылки на видеозаписи:**
- [Выполнения лабораторной работы](https://rutube.ru/video/private/fc6e40e60770e1351f382a67741f7c28/?p=pomyNyzSk9J-N-vfVueELw)
- [Запись отчёта](https://rutube.ru/video/private/3cf2fc5a2ec8ddc3b5100001da6c77a5/?p=q32-ZuUbuISB7qI28DQOtw)
- [Запись презентации](https://rutube.ru/video/private/f0c8623f6215bcffa6c278cb3a2e9006/?p=Zekk_y8ZW-fLeXeLrKwcMw)
- [Защита лабораторной работы](https://rutube.ru/video/private/7522eaf8956702071c72bad223e4aa13/?p=D1awNtNTcAuIk71GG-w8zA)

```

