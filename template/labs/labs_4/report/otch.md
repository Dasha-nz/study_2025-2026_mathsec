### Отчёт по лабораторной работе №4: Вычисление наибольшего общего делителя

### Дисциплина: Математические основы защиты информации и информационной безопасности

### Назарова Дарья Владиславовна

# Общая информация о задании лабораторной работы

## Цель работы

Ознакомиться с алгоритмами вычисления наибольшего общего делителя.

## Задание [@lab-task]

1. Реализовать алгоритм Евклида;
2. Реализовать бинарный алгоритм Евклида;
3. Реализовать расширенный алгоритм Евклида;
4. Реализовать расширенный бинарный алгоритм Евклида.

# Теоретическое введение [@infobez-course]

## Наибольший общий делитель чисел

Наибольший общий делитель (НОД) целых чисел a₁, a₂, ..., aₖ - это наибольшее натуральное число d, которое делит каждое из этих чисел без остатка.

Основные свойства НОД:
- НОД(a, b) = НОД(b, a mod b)
- НОД(a, 0) = |a|
- Если оба числа четные: НОД(a, b) = 2·НОД(a/2, b/2)
- Если одно четное, другое нечетное: НОД(a, b) = НОД(a/2, b) или НОД(a, b/2)

## Алгоритмы вычисления НОД

**Алгоритм Евклида** основан на последовательном применении формулы: 
НОД(a, b) = НОД(b, a mod b)

**Бинарный алгоритм Евклида** использует двоичное представление чисел и операции сдвига вместо деления, что делает его более эффективным при компьютерной реализации.

**Расширенный алгоритм Евклида** находит не только НОД, но и коэффициенты Безу x, y такие, что ax + by = НОД(a, b).

**Расширенный бинарный алгоритм Евклида** сочетает преимущества бинарного алгоритма с возможностью нахождения коэффициентов Безу.

# Выполнение лабораторной работы [@lab-task]

## Реализовать алгоритм Евклида

Алгоритм Евклида - это классический алгоритм для нахождения наибольшего общего делителя двух чисел, основанный на последовательном делении с остатком.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции, осуществляющей рассчёт НОД по алгоритму Евклида, представлен ниже.

```julia
function euclidean_gcd(a, b)
    a, b = abs(a), abs(b)
    while b != 0
        a, b = b, a % b
    end
    return a
end
```

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

Функцию саму можно поделить на несколько смысловых частей:

1. Приведение чисел к абсолютным значениям;
2. Последовательная замена пар чисел (a, b) на (b, a mod b);
3. Возврат результата когда остаток становится нулевым.

### Предобработка данных

Предобработка данных включает в себя приведение чисел к абсолютным значениям для корректной работы алгоритма с отрицательными числами.

```julia
a, b = abs(a), abs(b)
```

Эта часть кода гарантирует, что алгоритм будет работать с положительными числами, что соответствует математическому определению НОД.

### Основной цикл алгоритма

Основная логика алгоритма реализована в цикле while:

```julia
while b != 0
    a, b = b, a % b
end
```

На каждой итерации большее число заменяется меньшим, а меньшее - остатком от деления большего на меньшее. Процесс продолжается до тех пор, пока остаток не станет равным нулю.

### Проверка работы функции

Для проверки корректности реализации алгоритма Евклида используется тестирование на различных парах чисел.

```julia
println("НОД(12345, 24690) = ", euclidean_gcd(12345, 24690))
println("НОД(12345, 54321) = ", euclidean_gcd(12345, 54321))
```

## Реализовать бинарный алгоритм Евклида

Бинарный алгоритм Евклида использует двоичное представление чисел и операции сдвига, что делает его более эффективным для компьютерной реализации.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции, осуществляющей рассчёт НОД по бинарному алгоритму Евклида, представлен ниже.

```julia
function binary_gcd(a, b)
    a, b = abs(a), abs(b)
    g = 1
    
    while iseven(a) && iseven(b)
        a ÷= 2
        b ÷= 2
        g *= 2
    end
    
    u, v = a, b
    while u != 0
        while iseven(u)
            u ÷= 2
        end
        while iseven(v)
            v ÷= 2
        end
        if u >= v
            u -= v
        else
            v -= u
        end
    end
    
    return g * v
end
```

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

Функцию саму можно поделить на несколько смысловых частей:

1. Удаление общих множителей 2;
2. Работа с нечетными числами через вычитание;
3. Использование операций сдвига вместо деления.

### Удаление общих множителей 2

```julia
while iseven(a) && iseven(b)
    a ÷= 2
    b ÷= 2
    g *= 2
end
```

Эта часть удаляет все общие множители 2, сохраняя их в переменной `g`.

### Обработка нечетных чисел

```julia
u, v = a, b
while u != 0
    while iseven(u)
        u ÷= 2
    end
    while iseven(v)
        v ÷= 2
    end
    if u >= v
        u -= v
    else
        v -= u
    end
end
```

Основной цикл обрабатывает числа, удаляя оставшиеся множители 2 и применяя вычитание для нахождения НОД.

### Проверка работы функции

Для проверки корректности реализации бинарного алгоритма используется тестирование на различных парах чисел.

```julia
println("Бинарный НОД(91, 105) = ", binary_gcd(91, 105))
println("Бинарный НОД(105, 154) = ", binary_gcd(105, 154))
```

## Реализовать расширенный алгоритм Евклида

Расширенный алгоритм Евклида находит не только НОД двух чисел, но и коэффициенты Безу, удовлетворяющие уравнению ax + by = НОД(a,b).

Исходный код написан на языке `Julia` [@doc-julia]. Код функции, осуществляющей рассчёт НОД по расширенному алгоритму Евклида, представлен ниже.

```julia
function extended_euclidean(a, b)
    a, b = abs(a), abs(b)
    x0, x1 = 1, 0
    y0, y1 = 0, 1
    
    while b != 0
        q = a ÷ b
        a, b = b, a % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    end
    
    return (a, x0, y0)
end
```

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

Функцию саму можно поделить на несколько смысловых частей:

1. Инициализация коэффициентов Безу;
2. Последовательное обновление коэффициентов при делении с остатком;
3. Возврат НОД и коэффициентов x, y.

### Инициализация коэффициентов

```julia
x0, x1 = 1, 0
y0, y1 = 0, 1
```

Инициализируются начальные значения коэффициентов Безу.

### Основной цикл алгоритма

```julia
while b != 0
    q = a ÷ b
    a, b = b, a % b
    x0, x1 = x1, x0 - q * x1
    y0, y1 = y1, y0 - q * y1
end
```

На каждой итерации обновляются не только числа a и b, но и коэффициенты x и y.

### Проверка работы функции

При проверке корректности реализации важно проверять выполнение равенства Безу: a*x + b*y = НОД(a,b)

```julia
d, x, y = extended_euclidean(91, 105)
println("НОД(91,105) = $d, x = $x, y = $y")
println("Проверка: 91*$x + 105*$y = $(91*x + 105*y)")
```

## Реализовать расширенный бинарный алгоритм Евклида

Расширенный бинарный алгоритм Евклида сочетает эффективность бинарного алгоритма с возможностью нахождения коэффициентов Безу.

Исходный код написан на языке `Julia` [@doc-julia]. Код функции, осуществляющей рассчёт НОД по расширенному бинарному алгоритму Евклида, представлен ниже.

```julia
function extended_binary_gcd(a, b)
    a, b = abs(a), abs(b)
    g = 1
    
    while iseven(a) && iseven(b)
        a ÷= 2
        b ÷= 2
        g *= 2
    end
    
    u, v = a, b
    A, B, C, D = 1, 0, 0, 1
    
    while u != 0
        while iseven(u)
            u ÷= 2
            if iseven(A) && iseven(B)
                A ÷= 2
                B ÷= 2
            else
                A = (A + b) ÷ 2
                B = (B - a) ÷ 2
            end
        end
        
        while iseven(v)
            v ÷= 2
            if iseven(C) && iseven(D)
                C ÷= 2
                D ÷= 2
            else
                C = (C + b) ÷ 2
                D = (D - a) ÷ 2
            end
        end
        
        if u >= v
            u -= v
            A -= C
            B -= D
        else
            v -= u
            C -= A
            D -= B
        end
    end
    
    d = g * v
    return (d, C, D)
end
```

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

Функцию саму можно поделить на несколько смысловых частей:

1. Удаление общих множителей 2 с сохранением множителя g;
2. Обработка четных чисел с обновлением коэффициентов;
3. Вычитание и обновление матриц коэффициентов;
4. Возврат НОД и коэффициентов Безу.

### Удаление общих множителей 2

```julia
while iseven(a) && iseven(b)
    a ÷= 2
    b ÷= 2
    g *= 2
end
```

Как и в бинарном алгоритме, удаляются общие множители 2.

### Обработка четных чисел с обновлением коэффициентов

```julia
while iseven(u)
    u ÷= 2
    if iseven(A) && iseven(B)
        A ÷= 2
        B ÷= 2
    else
        A = (A + b) ÷ 2
        B = (B - a) ÷ 2
    end
end
```

При обработке четных чисел соответствующим образом обновляются коэффициенты.

### Проверка работы функции

При проверке корректности реализации важно проверять что расширенный бинарный алгоритм дает те же результаты что и обычный расширенный алгоритм.

```julia
d, x, y = extended_binary_gcd(91, 105)
println("Расширенный бинарный НОД(91,105) = $d, x = $x, y = $y")
println("Проверка: 91*$x + 105*$y = $(91*x + 105*y)")
```

## Тестирование всех алгоритмов

Для комплексной проверки всех реализованных алгоритмов написана тестовая функция:

```julia
function test_algorithms()
    test_cases = [
        (12345, 24690),
        (12345, 54321),
        (12345, 12541),
        (91, 105),
        (105, 154)
    ]
    
    for (a, b) in test_cases
        println("Тест для a=$a, b=$b:")
        println("Стандартный Евклид: ", euclidean_gcd(a, b))
        println("Бинарный алгоритм: ", binary_gcd(a, b))
        
        d1, x1, y1 = extended_euclidean(a, b)
        println("Расширенный Евклид: НОД=$d1, коэффициенты: x=$x1, y=$y1")
        
        d2, x2, y2 = extended_binary_gcd(a, b)
        println("Расширенный бинарный: НОД=$d2, коэффициенты: x=$x2, y=$y2")
        println("Проверка: $(a*x2 + b*y2) == $d2")
        println("-"^50)
    end
end

test_algorithms()
```

Эта функция тестирует все алгоритмы на нескольких парах чисел и проверяет корректность вычисления коэффициентов Безу.

# Выводы

В результате работы мы ознакомились с алгоритмами вычисления НОД, а именно:

- Алгоритмом Евклида;
- Бинарным алгоритмом Евклида;
- Расширенным алгоритмом Евклида;
- Расширенным бинарным алгоритмом Евклида.

Были успешно реализованы все четыре алгоритма на языке программирования Julia и проверена их корректность на тестовых примерах. Все алгоритмы демонстрируют корректные результаты вычисления наибольшего общего делителя и коэффициентов Безу.

Также были записаны скринкасты:

На RuTube:

- [Весь плейлист]()
- [Выполнения лабораторной работы]()
- [Запись отчёта]()
- [Запись презентации]()
- [Защита лабораторной работы]()

На Платформе:

- [Весь плейлист]()
- [Лабораторная работа]()
- [Отчёт]()
- [Презентация]()
