# Лабораторная работа №4: Вычисление наибольшего общего делителя
## Дисциплина: Математические основы защиты информации и информационной безопасности
### Назарова Дарья Владиславовна, НПИмд-01-24
### Российский университет дружбы народов, Москва, Россия
### октябрь 2025


# Общая информация о лабораторной работе

## Цель работы

Ознакомиться с алгоритмами вычисления наибольшего общего делителя.

## Задание

1. Реализовать алгоритм Евклида;
2. Реализовать бинарный алгоритм Евклида;
3. Реализовать расширенный алгоритм Евклида;
4. Реализовать расширенный бинарный алгоритм Евклида.

# Теоретическое введение

## Наибольший общий делитель

**Определение:**
НОД целых чисел a₁, a₂, ..., aₖ - наибольшее натуральное число d, которое делит каждое из этих чисел без остатка.

**Свойства:**
- НОД(a, b) = НОД(b, a mod b)
- НОД(a, 0) = |a|
- НОД(a, b) = 2·НОД(a/2, b/2) при четных a, b

**Основные алгоритмы:**
- Алгоритм Евклида
- Бинарный алгоритм Евклида  
- Расширенный алгоритм Евклида
- Расширенный бинарный алгоритм

**Применение:**
- Криптография
- Теория чисел
- Компьютерная алгебра

# Выполнение лабораторной работы

# 1. Реализовать алгоритм Евклида

```julia
function euclidean_gcd(a, b)
    a, b = abs(a), abs(b)
    while b != 0
        a, b = b, a % b
    end
    return a
end
```

## Работа функции (1)

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

## Работа функции (2)

Функцию саму можно поделить на несколько смысловых частей:

1. Приведение чисел к абсолютным значениям;
2. Последовательная замена пар чисел (a, b) на (b, a mod b);
3. Возврат результата когда остаток становится нулевым.

## Проверка работы функции

```julia
println("НОД(12345, 24690) = ", euclidean_gcd(12345, 24690))
println("НОД(12345, 54321) = ", euclidean_gcd(12345, 54321))
```

## Результат выполнения

```
НОД(12345, 24690) = 12345
НОД(12345, 54321) = 3
```

# 2. Реализовать бинарный алгоритм Евклида

```julia
function binary_gcd(a, b)
    a, b = abs(a), abs(b)
    g = 1
    
    while iseven(a) && iseven(b)
        a ÷= 2
        b ÷= 2
        g *= 2
    end
    
    u, v = a, b
    while u != 0
        while iseven(u)
            u ÷= 2
        end
        while iseven(v)
            v ÷= 2
        end
        if u >= v
            u -= v
        else
            v -= u
        end
    end
    
    return g * v
end
```

## Работа функции (1)

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

## Работа функции (2)

Функцию саму можно поделить на несколько смысловых частей:

1. Удаление общих множителей 2;
2. Работа с нечетными числами через вычитание;
3. Использование операций сдвига вместо деления.

## Проверка работы функции

```julia
println("Бинарный НОД(91, 105) = ", binary_gcd(91, 105))
println("Бинарный НОД(105, 154) = ", binary_gcd(105, 154))
```

## Результат выполнения

```
Бинарный НОД(91, 105) = 7
Бинарный НОД(105, 154) = 7
```

# 3. Реализовать расширенный алгоритм Евклида

```julia
function extended_euclidean(a, b)
    a, b = abs(a), abs(b)
    x0, x1 = 1, 0
    y0, y1 = 0, 1
    
    while b != 0
        q = a ÷ b
        a, b = b, a % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    end
    
    return (a, x0, y0)
end
```

## Работа функции (1)

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

## Работа функции (2)

Функцию саму можно поделить на несколько смысловых частей:

1. Инициализация коэффициентов Безу;
2. Последовательное обновление коэффициентов при делении с остатком;
3. Возврат НОД и коэффициентов x, y.

## Проверка работы функции

```julia
d, x, y = extended_euclidean(91, 105)
println("НОД(91,105) = $d, x = $x, y = $y")
println("Проверка: 91*$x + 105*$y = $(91*x + 105*y)")
```

## Результат выполнения

```
НОД(91,105) = 7, x = -2, y = 1
Проверка: 91*-2 + 105*1 = 7
```

# 4. Реализовать расширенный бинарный алгоритм Евклида

```julia
function extended_binary_gcd(a, b)
    a, b = abs(a), abs(b)
    g = 1
    
    while iseven(a) && iseven(b)
        a ÷= 2
        b ÷= 2
        g *= 2
    end
    
    u, v = a, b
    A, B, C, D = 1, 0, 0, 1
    
    while u != 0
        while iseven(u)
            u ÷= 2
            if iseven(A) && iseven(B)
                A ÷= 2
                B ÷= 2
            else
                A = (A + b) ÷ 2
                B = (B - a) ÷ 2
            end
        end
        
        while iseven(v)
            v ÷= 2
            if iseven(C) && iseven(D)
                C ÷= 2
                D ÷= 2
            else
                C = (C + b) ÷ 2
                D = (D - a) ÷ 2
            end
        end
        
        if u >= v
            u -= v
            A -= C
            B -= D
        else
            v -= u
            C -= A
            D -= B
        end
    end
    
    d = g * v
    return (d, C, D)
end
```

## Работа функции (1)

Разберём подробно работу функции.

На вход функция принимает 2 параметра: 

- `a` -- первое целое число;
- `b` -- второе целое число.

## Работа функции (2)

Функцию саму можно поделить на несколько смысловых частей:

1. Удаление общих множителей 2 с сохранением множителя g;
2. Обработка четных чисел с обновлением коэффициентов;
3. Вычитание и обновление матриц коэффициентов;
4. Возврат НОД и коэффициентов Безу.

## Проверка работы функции

```julia
d, x, y = extended_binary_gcd(91, 105)
println("Расширенный бинарный НОД(91,105) = $d, x = $x, y = $y")
println("Проверка: 91*$x + 105*$y = $(91*x + 105*y)")
```

## Результат выполнения

```
Расширенный бинарный НОД(91,105) = 7, x = -2, y = 1
Проверка: 91*-2 + 105*1 = 7
```

# Тестирование всех алгоритмов

```julia
function test_algorithms()
    test_cases = [
        (12345, 24690),
        (12345, 54321),
        (12345, 12541),
        (91, 105),
        (105, 154)
    ]
    
    for (a, b) in test_cases
        println("Тест для a=$a, b=$b:")
        println("Стандартный Евклид: ", euclidean_gcd(a, b))
        println("Бинарный алгоритм: ", binary_gcd(a, b))
        
        d1, x1, y1 = extended_euclidean(a, b)
        println("Расширенный Евклид: НОД=$d1, коэффициенты: x=$x1, y=$y1")
        
        d2, x2, y2 = extended_binary_gcd(a, b)
        println("Расширенный бинарный: НОД=$d2, коэффициенты: x=$x2, y=$y2")
        println("Проверка: $(a*x2 + b*y2) == $d2")
        println("-"^50)
    end
end
```

## Результаты тестирования

Все алгоритмы успешно прошли тестирование:

- Корректно вычисляют НОД для различных пар чисел
- Правильно находят коэффициенты Безу
- Проходят проверку равенства a*x + b*y = НОД(a,b)

# Выводы

В результате работы мы ознакомились с алгоритмами вычисления НОД, а именно:

- **Алгоритмом Евклида** - классический подход с последовательным делением
- **Бинарным алгоритмом Евклида** - эффективная реализация с использованием операций сдвига
- **Расширенным алгоритмом Евклида** - нахождение НОД и коэффициентов Безу
- **Расширенным бинарным алгоритмом Евклида** - комбинация эффективности и функциональности

**Результаты:**
- Все алгоритмы успешно реализованы на языке Julia
- Проведено комплексное тестирование на различных примерах
- Подтверждена корректность вычислений
- Достигнута цель лабораторной работы

Были записаны скринкасты:
- выполнения лабораторной работы;
- создания отчёта по результатам выполнения лабораторной работы;
- создания презентации по результатам выполнения лабораторной работы;
- защиты лабораторной работы.
```
