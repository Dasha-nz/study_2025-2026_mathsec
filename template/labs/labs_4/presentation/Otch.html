<html><head><style>body {
   color: black;
}
</style></head><body><h3 id="-4-">Отчёт по лабораторной работе №4: Вычисление наибольшего общего делителя</h3>
<h3 id="-">Дисциплина: Математические основы защиты информации и информационной безопасности</h3>
<h3 id="-">Назарова Дарья Владиславовна</h3>
<h1 id="-">Общая информация о задании лабораторной работы</h1>
<h2 id="-">Цель работы</h2>
<p>Ознакомиться с алгоритмами вычисления наибольшего общего делителя.</p>
<h2 id="-lab-task-">Задание [@lab-task]</h2>
<ol>
<li>Реализовать алгоритм Евклида;</li>
<li>Реализовать бинарный алгоритм Евклида;</li>
<li>Реализовать расширенный алгоритм Евклида;</li>
<li>Реализовать расширенный бинарный алгоритм Евклида.</li>
</ol>
<h1 id="-infobez-course-">Теоретическое введение [@infobez-course]</h1>
<h2 id="-">Наибольший общий делитель чисел</h2>
<p>Наибольший общий делитель (НОД) целых чисел a₁, a₂, ..., aₖ - это наибольшее натуральное число d, которое делит каждое из этих чисел без остатка.</p>
<p>Основные свойства НОД:</p>
<ul>
<li>НОД(a, b) = НОД(b, a mod b)</li>
<li>НОД(a, 0) = |a|</li>
<li>Если оба числа четные: НОД(a, b) = 2·НОД(a/2, b/2)</li>
<li>Если одно четное, другое нечетное: НОД(a, b) = НОД(a/2, b) или НОД(a, b/2)</li>
</ul>
<h2 id="-">Алгоритмы вычисления НОД</h2>
<p><strong>Алгоритм Евклида</strong> основан на последовательном применении формулы: 
НОД(a, b) = НОД(b, a mod b)</p>
<p><strong>Бинарный алгоритм Евклида</strong> использует двоичное представление чисел и операции сдвига вместо деления, что делает его более эффективным при компьютерной реализации.</p>
<p><strong>Расширенный алгоритм Евклида</strong> находит не только НОД, но и коэффициенты Безу x, y такие, что ax + by = НОД(a, b).</p>
<p><strong>Расширенный бинарный алгоритм Евклида</strong> сочетает преимущества бинарного алгоритма с возможностью нахождения коэффициентов Безу.</p>
<h1 id="-lab-task-">Выполнение лабораторной работы [@lab-task]</h1>
<h2 id="-">Реализовать алгоритм Евклида</h2>
<p>Алгоритм Евклида - это классический алгоритм для нахождения наибольшего общего делителя двух чисел, основанный на последовательном делении с остатком.</p>
<p>Исходный код написан на языке <code>Julia</code> [@doc-julia]. Код функции, осуществляющей рассчёт НОД по алгоритму Евклида, представлен ниже.</p>
<pre><code class="lang-julia"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">euclidean_gcd</span>(<span class="hljs-title">a</span>, <span class="hljs-title">b</span>)</span>
    <span class="hljs-keyword">a</span>, b = <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">a</span>), <span class="hljs-built_in">abs</span>(b)
    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>
        <span class="hljs-keyword">a</span>, b = b, <span class="hljs-keyword">a</span> % b
    <span class="hljs-function"><span class="hljs-keyword">end</span>
    <span class="hljs-title">return</span> <span class="hljs-title">a</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Разберём подробно работу функции.</p>
<p>На вход функция принимает 2 параметра: </p>
<ul>
<li><code>a</code> -- первое целое число;</li>
<li><code>b</code> -- второе целое число.</li>
</ul>
<p>Функцию саму можно поделить на несколько смысловых частей:</p>
<ol>
<li>Приведение чисел к абсолютным значениям;</li>
<li>Последовательная замена пар чисел (a, b) на (b, a mod b);</li>
<li>Возврат результата когда остаток становится нулевым.</li>
</ol>
<h3 id="-">Предобработка данных</h3>
<p>Предобработка данных включает в себя приведение чисел к абсолютным значениям для корректной работы алгоритма с отрицательными числами.</p>
<pre><code class="lang-julia"><span class="hljs-keyword">a</span>, b = <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">a</span>), <span class="hljs-built_in">abs</span>(b)
</code></pre>
<p>Эта часть кода гарантирует, что алгоритм будет работать с положительными числами, что соответствует математическому определению НОД.</p>
<h3 id="-">Основной цикл алгоритма</h3>
<p>Основная логика алгоритма реализована в цикле while:</p>
<pre><code class="lang-julia"><span class="hljs-symbol">while</span> <span class="hljs-keyword">b </span>!= <span class="hljs-number">0</span>
    a, <span class="hljs-keyword">b </span>= <span class="hljs-keyword">b, </span>a % <span class="hljs-keyword">b
</span><span class="hljs-symbol">end</span>
</code></pre>
<p>На каждой итерации большее число заменяется меньшим, а меньшее - остатком от деления большего на меньшее. Процесс продолжается до тех пор, пока остаток не станет равным нулю.</p>
<h3 id="-">Проверка работы функции</h3>
<p>Для проверки корректности реализации алгоритма Евклида используется тестирование на различных парах чисел.</p>
<pre><code class="lang-julia"><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"НОД(12345, 24690) = "</span>, euclidean_gcd(<span class="hljs-number">12345</span>, <span class="hljs-number">24690</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"НОД(12345, 54321) = "</span>, euclidean_gcd(<span class="hljs-number">12345</span>, <span class="hljs-number">54321</span>)</span></span>)
</code></pre>
<h2 id="-">Реализовать бинарный алгоритм Евклида</h2>
<p>Бинарный алгоритм Евклида использует двоичное представление чисел и операции сдвига, что делает его более эффективным для компьютерной реализации.</p>
<p>Исходный код написан на языке <code>Julia</code> [@doc-julia]. Код функции, осуществляющей рассчёт НОД по бинарному алгоритму Евклида, представлен ниже.</p>
<pre><code class="lang-julia"><span class="hljs-symbol">function</span> <span class="hljs-keyword">binary_gcd(a, </span><span class="hljs-keyword">b)
</span>    a, <span class="hljs-keyword">b </span>= abs(a), abs(<span class="hljs-keyword">b)
</span>    g = <span class="hljs-number">1</span>

    <span class="hljs-meta">while</span> iseven(a) &amp;&amp; iseven(<span class="hljs-keyword">b)
</span>        a ÷= <span class="hljs-number">2</span>
        <span class="hljs-keyword">b </span>÷= <span class="hljs-number">2</span>
        g *= <span class="hljs-number">2</span>
    <span class="hljs-meta">end</span>

    u, v = a, <span class="hljs-keyword">b
</span>    <span class="hljs-meta">while</span> u != <span class="hljs-number">0</span>
        <span class="hljs-meta">while</span> iseven(u)
            u ÷= <span class="hljs-number">2</span>
        <span class="hljs-meta">end</span>
        <span class="hljs-meta">while</span> iseven(v)
            v ÷= <span class="hljs-number">2</span>
        <span class="hljs-meta">end</span>
        <span class="hljs-meta">if</span> u &gt;= v
            u -= v
        <span class="hljs-meta">else</span>
            v -= u
        <span class="hljs-meta">end</span>
    <span class="hljs-meta">end</span>

    return g * v
<span class="hljs-symbol">end</span>
</code></pre>
<p>Разберём подробно работу функции.</p>
<p>На вход функция принимает 2 параметра: </p>
<ul>
<li><code>a</code> -- первое целое число;</li>
<li><code>b</code> -- второе целое число.</li>
</ul>
<p>Функцию саму можно поделить на несколько смысловых частей:</p>
<ol>
<li>Удаление общих множителей 2;</li>
<li>Работа с нечетными числами через вычитание;</li>
<li>Использование операций сдвига вместо деления.</li>
</ol>
<h3 id="-2">Удаление общих множителей 2</h3>
<pre><code class="lang-julia">while iseven(a) &amp;&amp; iseven(b)
    a ÷= <span class="hljs-number">2</span>
    b ÷= <span class="hljs-number">2</span>
    g *= <span class="hljs-number">2</span>
end
</code></pre>
<p>Эта часть удаляет все общие множители 2, сохраняя их в переменной <code>g</code>.</p>
<h3 id="-">Обработка нечетных чисел</h3>
<pre><code class="lang-julia">u, v = a, b
<span class="hljs-keyword">while</span> u != <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> iseven(u)
        u ÷= <span class="hljs-number">2</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">while</span> iseven(v)
        v ÷= <span class="hljs-number">2</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">if</span> u &gt;= v
        u -= v
    <span class="hljs-keyword">else</span>
        v -= u
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Основной цикл обрабатывает числа, удаляя оставшиеся множители 2 и применяя вычитание для нахождения НОД.</p>
<h3 id="-">Проверка работы функции</h3>
<p>Для проверки корректности реализации бинарного алгоритма используется тестирование на различных парах чисел.</p>
<pre><code class="lang-julia"><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"Бинарный НОД(91, 105) = "</span>, binary_gcd(<span class="hljs-number">91</span>, <span class="hljs-number">105</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"Бинарный НОД(105, 154) = "</span>, binary_gcd(<span class="hljs-number">105</span>, <span class="hljs-number">154</span>)</span></span>)
</code></pre>
<h2 id="-">Реализовать расширенный алгоритм Евклида</h2>
<p>Расширенный алгоритм Евклида находит не только НОД двух чисел, но и коэффициенты Безу, удовлетворяющие уравнению ax + by = НОД(a,b).</p>
<p>Исходный код написан на языке <code>Julia</code> [@doc-julia]. Код функции, осуществляющей рассчёт НОД по расширенному алгоритму Евклида, представлен ниже.</p>
<pre><code class="lang-julia"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extended_euclidean</span>(<span class="hljs-title">a</span>, <span class="hljs-title">b</span>)</span>
    <span class="hljs-keyword">a</span>, b = <span class="hljs-built_in">abs</span>(<span class="hljs-keyword">a</span>), <span class="hljs-built_in">abs</span>(b)
    x0, x1 = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
    y0, y1 = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>

    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>
        q = <span class="hljs-keyword">a</span> ÷ b
        <span class="hljs-keyword">a</span>, b = b, <span class="hljs-keyword">a</span> % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    <span class="hljs-function"><span class="hljs-keyword">end</span>

    <span class="hljs-title">return</span> (<span class="hljs-title">a</span>, <span class="hljs-title">x0</span>, <span class="hljs-title">y0</span>)</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Разберём подробно работу функции.</p>
<p>На вход функция принимает 2 параметра: </p>
<ul>
<li><code>a</code> -- первое целое число;</li>
<li><code>b</code> -- второе целое число.</li>
</ul>
<p>Функцию саму можно поделить на несколько смысловых частей:</p>
<ol>
<li>Инициализация коэффициентов Безу;</li>
<li>Последовательное обновление коэффициентов при делении с остатком;</li>
<li>Возврат НОД и коэффициентов x, y.</li>
</ol>
<h3 id="-">Инициализация коэффициентов</h3>
<pre><code class="lang-julia">x0, x1 = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
y0, y1 = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
</code></pre>
<p>Инициализируются начальные значения коэффициентов Безу.</p>
<h3 id="-">Основной цикл алгоритма</h3>
<pre><code class="lang-julia"><span class="hljs-symbol">while</span> <span class="hljs-keyword">b </span>!= <span class="hljs-number">0</span>
    q = a ÷ <span class="hljs-keyword">b
</span>    a, <span class="hljs-keyword">b </span>= <span class="hljs-keyword">b, </span>a % <span class="hljs-keyword">b
</span>    x0, x1 = x1, x0 - q * x1
    y0, y1 = y1, y0 - q * y1
<span class="hljs-symbol">end</span>
</code></pre>
<p>На каждой итерации обновляются не только числа a и b, но и коэффициенты x и y.</p>
<h3 id="-">Проверка работы функции</h3>
<p>При проверке корректности реализации важно проверять выполнение равенства Безу: a<em>x + b</em>y = НОД(a,b)</p>
<pre><code class="lang-julia">d, x, y = extended_euclidean(91, 105)
println(<span class="hljs-string">"НОД(91,105) = <span class="hljs-variable">$d</span>, x = <span class="hljs-variable">$x</span>, y = <span class="hljs-variable">$y</span>"</span>)
println(<span class="hljs-string">"Проверка: 91*<span class="hljs-variable">$x</span> + 105*<span class="hljs-variable">$y</span> = <span class="hljs-variable">$(91*x + 105*y)</span>"</span>)
</code></pre>
<h2 id="-">Реализовать расширенный бинарный алгоритм Евклида</h2>
<p>Расширенный бинарный алгоритм Евклида сочетает эффективность бинарного алгоритма с возможностью нахождения коэффициентов Безу.</p>
<p>Исходный код написан на языке <code>Julia</code> [@doc-julia]. Код функции, осуществляющей рассчёт НОД по расширенному бинарному алгоритму Евклида, представлен ниже.</p>
<pre><code class="lang-julia"><span class="hljs-symbol">function</span> extended_binary_gcd(a, <span class="hljs-keyword">b)
</span>    a, <span class="hljs-keyword">b </span>= abs(a), abs(<span class="hljs-keyword">b)
</span>    g = <span class="hljs-number">1</span>

    <span class="hljs-meta">while</span> iseven(a) &amp;&amp; iseven(<span class="hljs-keyword">b)
</span>        a ÷= <span class="hljs-number">2</span>
        <span class="hljs-keyword">b </span>÷= <span class="hljs-number">2</span>
        g *= <span class="hljs-number">2</span>
    <span class="hljs-meta">end</span>

    u, v = a, <span class="hljs-keyword">b
</span>    A, <span class="hljs-keyword">B, </span>C, D = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>

    <span class="hljs-meta">while</span> u != <span class="hljs-number">0</span>
        <span class="hljs-meta">while</span> iseven(u)
            u ÷= <span class="hljs-number">2</span>
            <span class="hljs-meta">if</span> iseven(A) &amp;&amp; iseven(<span class="hljs-keyword">B)
</span>                A ÷= <span class="hljs-number">2</span>
                <span class="hljs-keyword">B </span>÷= <span class="hljs-number">2</span>
            <span class="hljs-meta">else</span>
                A = (A + <span class="hljs-keyword">b) </span>÷ <span class="hljs-number">2</span>
                <span class="hljs-keyword">B </span>= (<span class="hljs-keyword">B </span>- a) ÷ <span class="hljs-number">2</span>
            <span class="hljs-meta">end</span>
        <span class="hljs-meta">end</span>

        <span class="hljs-meta">while</span> iseven(v)
            v ÷= <span class="hljs-number">2</span>
            <span class="hljs-meta">if</span> iseven(C) &amp;&amp; iseven(D)
                C ÷= <span class="hljs-number">2</span>
                D ÷= <span class="hljs-number">2</span>
            <span class="hljs-meta">else</span>
                C = (C + <span class="hljs-keyword">b) </span>÷ <span class="hljs-number">2</span>
                D = (D - a) ÷ <span class="hljs-number">2</span>
            <span class="hljs-meta">end</span>
        <span class="hljs-meta">end</span>

        <span class="hljs-meta">if</span> u &gt;= v
            u -= v
            A -= C
            <span class="hljs-keyword">B </span>-= D
        <span class="hljs-meta">else</span>
            v -= u
            C -= A
            D -= <span class="hljs-keyword">B
</span>        <span class="hljs-meta">end</span>
    <span class="hljs-meta">end</span>

    d = g * v
    return (d, C, D)
<span class="hljs-symbol">end</span>
</code></pre>
<p>Разберём подробно работу функции.</p>
<p>На вход функция принимает 2 параметра: </p>
<ul>
<li><code>a</code> -- первое целое число;</li>
<li><code>b</code> -- второе целое число.</li>
</ul>
<p>Функцию саму можно поделить на несколько смысловых частей:</p>
<ol>
<li>Удаление общих множителей 2 с сохранением множителя g;</li>
<li>Обработка четных чисел с обновлением коэффициентов;</li>
<li>Вычитание и обновление матриц коэффициентов;</li>
<li>Возврат НОД и коэффициентов Безу.</li>
</ol>
<h3 id="-2">Удаление общих множителей 2</h3>
<pre><code class="lang-julia">while iseven(a) &amp;&amp; iseven(b)
    a ÷= <span class="hljs-number">2</span>
    b ÷= <span class="hljs-number">2</span>
    g *= <span class="hljs-number">2</span>
end
</code></pre>
<p>Как и в бинарном алгоритме, удаляются общие множители 2.</p>
<h3 id="-">Обработка четных чисел с обновлением коэффициентов</h3>
<pre><code class="lang-julia"><span class="hljs-symbol">while</span> iseven(u)
    u ÷= <span class="hljs-number">2</span>
    <span class="hljs-meta">if</span> iseven(A) &amp;&amp; iseven(<span class="hljs-keyword">B)
</span>        A ÷= <span class="hljs-number">2</span>
        <span class="hljs-keyword">B </span>÷= <span class="hljs-number">2</span>
    <span class="hljs-meta">else</span>
        A = (A + <span class="hljs-keyword">b) </span>÷ <span class="hljs-number">2</span>
        <span class="hljs-keyword">B </span>= (<span class="hljs-keyword">B </span>- a) ÷ <span class="hljs-number">2</span>
    <span class="hljs-meta">end</span>
<span class="hljs-symbol">end</span>
</code></pre>
<p>При обработке четных чисел соответствующим образом обновляются коэффициенты.</p>
<h3 id="-">Проверка работы функции</h3>
<p>При проверке корректности реализации важно проверять что расширенный бинарный алгоритм дает те же результаты что и обычный расширенный алгоритм.</p>
<pre><code class="lang-julia">d, x, y = extended_binary_gcd(91, 105)
println(<span class="hljs-string">"Расширенный бинарный НОД(91,105) = <span class="hljs-variable">$d</span>, x = <span class="hljs-variable">$x</span>, y = <span class="hljs-variable">$y</span>"</span>)
println(<span class="hljs-string">"Проверка: 91*<span class="hljs-variable">$x</span> + 105*<span class="hljs-variable">$y</span> = <span class="hljs-variable">$(91*x + 105*y)</span>"</span>)
</code></pre>
<h2 id="-">Тестирование всех алгоритмов</h2>
<p>Для комплексной проверки всех реализованных алгоритмов написана тестовая функция:</p>
<pre><code class="lang-julia"><span class="hljs-keyword">function</span> test_algorithms()
    test_cases = [
        (<span class="hljs-number">12345</span>, <span class="hljs-number">24690</span>),
        (<span class="hljs-number">12345</span>, <span class="hljs-number">54321</span>),
        (<span class="hljs-number">12345</span>, <span class="hljs-number">12541</span>),
        (<span class="hljs-number">91</span>, <span class="hljs-number">105</span>),
        (<span class="hljs-number">105</span>, <span class="hljs-number">154</span>)
    ]

    <span class="hljs-keyword">for</span> (a, b) <span class="hljs-keyword">in</span> test_cases
        println(<span class="hljs-string">"Тест для a=<span class="hljs-variable">$a</span>, b=<span class="hljs-variable">$b</span>:"</span>)
        println(<span class="hljs-string">"Стандартный Евклид: "</span>, euclidean_gcd(a, b))
        println(<span class="hljs-string">"Бинарный алгоритм: "</span>, binary_gcd(a, b))

        d1, x1, y1 = extended_euclidean(a, b)
        println(<span class="hljs-string">"Расширенный Евклид: НОД=<span class="hljs-variable">$d1</span>, коэффициенты: x=<span class="hljs-variable">$x1</span>, y=<span class="hljs-variable">$y1</span>"</span>)

        d2, x2, y2 = extended_binary_gcd(a, b)
        println(<span class="hljs-string">"Расширенный бинарный: НОД=<span class="hljs-variable">$d2</span>, коэффициенты: x=<span class="hljs-variable">$x2</span>, y=<span class="hljs-variable">$y2</span>"</span>)
        println(<span class="hljs-string">"Проверка: <span class="hljs-subst">$(a*x2 + b*y2)</span> == <span class="hljs-variable">$d2</span>"</span>)
        println(<span class="hljs-string">"-"</span>^<span class="hljs-number">50</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

test_algorithms()
</code></pre>
<p>Эта функция тестирует все алгоритмы на нескольких парах чисел и проверяет корректность вычисления коэффициентов Безу.</p>
<h1 id="-">Выводы</h1>
<p>В результате работы мы ознакомились с алгоритмами вычисления НОД, а именно:</p>
<ul>
<li>Алгоритмом Евклида;</li>
<li>Бинарным алгоритмом Евклида;</li>
<li>Расширенным алгоритмом Евклида;</li>
<li>Расширенным бинарным алгоритмом Евклида.</li>
</ul>
<p>Были успешно реализованы все четыре алгоритма на языке программирования Julia и проверена их корректность на тестовых примерах. Все алгоритмы демонстрируют корректные результаты вычисления наибольшего общего делителя и коэффициентов Безу.</p>
<p>Также были записаны скринкасты:</p>
<p>На RuTube:</p>
<ul>
<li><a href="">Весь плейлист</a></li>
<li><a href="">Выполнения лабораторной работы</a></li>
<li><a href="">Запись отчёта</a></li>
<li><a href="">Запись презентации</a></li>
<li><a href="">Защита лабораторной работы</a></li>
</ul>
<p>На Платформе:</p>
<ul>
<li><a href="">Весь плейлист</a></li>
<li><a href="">Лабораторная работа</a></li>
<li><a href="">Отчёт</a></li>
<li><a href="">Презентация</a></li>
</ul>
</body></html>